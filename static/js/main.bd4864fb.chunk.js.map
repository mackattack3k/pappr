{"version":3,"sources":["utils.ts","config.ts","useRandomHotImage.ts","Background.tsx","Home.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["randomValueFromArray","array","min","max","length","Math","floor","random","devLog","l","REDIRECT_URL","window","location","protocol","host","authUrl","fetchImage","fromSubreddit","accessToken","a","fetch","headers","Authorization","r","json","jsonR","error","posts","data","children","images","map","post","url","randomImage","defaultSubs","Background","hotImage","useState","image","setFoundImage","access","localStorage","getItem","subs","availableSubs","JSON","parse","selectedSubreddit","useEffect","parsedAccess","access_token","expiryDate","needsAccessRefresh","Date","fetchHot","updateBearer","then","catch","isLoading","subReddit","useRandomHotImage","hasBrowserLoadedImage","setHasLoadedImage","className","onClick","clear","reload","src","onLoad","alt","Home","href","refresh_token","method","btoa","CLIENT_ID","body","stringify","grant_type","fetchUpdate","parsedResponse","setSeconds","getSeconds","expires_in","setItem","Auth","useLocation","history","useHistory","code","search","redirect_uri","fetchBearer","push","getBearer","App","basename","process","exact","path","component","to","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","console","message"],"mappings":"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","file":"static/js/main.bd4864fb.chunk.js","sourcesContent":["const randomIntFromInterval = (min: number, max: number) => {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nexport const randomValueFromArray = (array: any[]) => {\n  const pos = randomIntFromInterval(0, array.length - 1);\n  return array[pos];\n};\n\nconst isDev = process.env.NODE_ENV === \"development\";\nexport const devLog = (l: any) => {\n  if (!isDev) {\n    return;\n  }\n  console.log(l);\n};\n","export const corsPrefix =\n  process.env.NODE_ENV === \"production\"\n    ? \"\"\n    : \"https://cors-anywhere.herokuapp.com/\";\nexport const CLIENT_ID =\n  process.env.NODE_ENV === \"production\"\n    ? \"NxTWOwoh3zE_GA\"\n    : process.env.REACT_APP_REDDIT_CLIENT_ID;\nexport const REDIRECT_URL = `${window.location.protocol}//${window.location.host}/pappr/auth`;\nexport const authUrl = `https://www.reddit.com/api/v1/authorize?client_id=${CLIENT_ID}&response_type=code&duration=permanent&state=RANDOM_STRING&scope=read&redirect_uri=${REDIRECT_URL}`;\nexport const API_URL = `https://oauth.reddit.com/`;\n","import { useEffect, useState } from \"react\";\nimport { devLog, randomValueFromArray } from \"./utils\";\nimport { API_URL } from \"./config\";\nimport { updateBearer } from \"./App\";\n\ninterface Post {\n  data: {\n    url: string;\n  };\n}\n\nconst fetchImage = async (fromSubreddit: string, accessToken: string) => {\n  try {\n    if (!accessToken) {\n      devLog(`Tried to fetch image without access token (${accessToken})`);\n      return;\n    }\n    const r = await fetch(`${API_URL}r/${fromSubreddit}/hot`, {\n      headers: {\n        Authorization: `bearer ${accessToken}`,\n        //\"User-Agent\": `Web:${CLIENT_ID}:0.0.1 (by /u/mackattack3k)`,\n      },\n    });\n    const jsonR = await r.json();\n    if (jsonR.error) {\n      devLog(jsonR.error);\n      return \"nodata\";\n    }\n    devLog({ jsonResponse: jsonR });\n    const posts = jsonR.data.children as Post[];\n    devLog({ allPosts: posts });\n    const images = posts.map((post) => post.data.url);\n    const randomImage = randomValueFromArray(images);\n    devLog({ randomImage });\n    return randomImage;\n  } catch (e) {\n    return \"nodata\";\n  }\n};\n\nconst defaultSubs = [\n  \"EarthPorn\",\n  \"CityPorn\",\n  \"SkyPorn\",\n  \"WeatherPorn\",\n  \"BotanicalPorn\",\n  \"LakePorn\",\n  \"VillagePorn\",\n  \"BeachPorn\",\n  \"WaterPorn\",\n  \"SpacePorn\",\n  \"multiwall\",\n  \"wallpapers\",\n  \"wallpaper\",\n];\nexport const useRandomHotImage = () => {\n  const [image, setFoundImage] = useState<string>();\n  const access = window.localStorage.getItem(\"access\");\n  const subs = window.localStorage.getItem(\"subs\");\n  let availableSubs = subs ? JSON.parse(subs) : defaultSubs;\n  const selectedSubreddit = randomValueFromArray(availableSubs);\n  useEffect(() => {\n    if (!access) {\n      return;\n    }\n    if (image) {\n      return;\n    }\n    devLog(\n      `Selected random subreddit ${selectedSubreddit} from ${availableSubs}`\n    );\n    const parsedAccess = JSON.parse(access);\n    const { access_token: accessToken, expiryDate } = parsedAccess;\n    const needsAccessRefresh = new Date(expiryDate) < new Date();\n    const fetchHot = async () => {\n      devLog(\"useEffect start fetch\");\n      devLog(access);\n      const image = await fetchImage(selectedSubreddit, accessToken);\n      setFoundImage(image);\n      devLog(\"useEffect done\");\n    };\n    if (needsAccessRefresh) {\n      devLog(\"Needs update of bearer\");\n      updateBearer().then(fetchHot);\n      return;\n    }\n    fetchHot().catch(devLog);\n  }, [access, availableSubs, selectedSubreddit, image]);\n  return {\n    image,\n    isLoading: !image,\n    subReddit: selectedSubreddit,\n  };\n};\n","import React, { useState } from \"react\";\nimport { useRandomHotImage } from \"./useRandomHotImage\";\n\nconst Background = () => {\n  const hotImage = useRandomHotImage();\n  const [hasBrowserLoadedImage, setHasLoadedImage] = useState<boolean>();\n  if (hotImage.isLoading) {\n    return (\n      <div className=\"loading\">\n        <h1>Loading from /r/{hotImage.subReddit}</h1>\n      </div>\n    );\n  }\n  if (hotImage.image === \"nodata\") {\n    const clearSavedData = () => {\n      localStorage.clear();\n      window.location.reload();\n    };\n    return (\n      <div className=\"loading\">\n        <h1>Error getting image</h1>\n        <button className=\"button\" onClick={clearSavedData}>\n          Clear saved data\n        </button>\n      </div>\n    );\n  }\n  return (\n    <>\n      {!hasBrowserLoadedImage && (\n        <div className=\"loading\">\n          <h1>Loading from /r/{hotImage.subReddit}</h1>\n        </div>\n      )}\n      <img\n        className={hasBrowserLoadedImage ? \"bg\" : \"bg hidden\"}\n        src={hotImage.image}\n        onLoad={() => setHasLoadedImage(true)}\n        alt=\"Wallpaper\"\n      />\n    </>\n  );\n};\n\nexport default Background;\n","import React from \"react\";\nimport { devLog } from \"./utils\";\nimport Background from \"./Background\";\nimport { authUrl } from \"./config\";\n\nconst Home = () => {\n  const access = window.localStorage.getItem(\"access\");\n  devLog({ access, authUrl });\n  if (!access) {\n    return (\n      <div className=\"home\">\n        <div>\n          Authenticate with your reddit account to fetch images. We only require\n          read access to posts.\n        </div>\n        <a className=\"button\" href={authUrl}>\n          Log in with your reddit account\n        </a>\n      </div>\n    );\n  }\n  return <Background />;\n};\n\nexport default Home;\n","import React from \"react\";\nimport {\n  BrowserRouter as Router,\n  Redirect,\n  Route,\n  Switch,\n  useHistory,\n  useLocation,\n} from \"react-router-dom\";\nimport { parse, stringify } from \"qs\";\nimport \"./App.css\";\nimport { devLog } from \"./utils\";\nimport { CLIENT_ID, corsPrefix, REDIRECT_URL } from \"./config\";\nimport Home from \"./Home\";\n\nexport const updateBearer = async () => {\n  const access = window.localStorage.getItem(\"access\");\n  if (!access) {\n    devLog(\"Clear access since we failed to get it. Need reAuth\");\n    localStorage.clear();\n    window.location.reload();\n    return;\n  }\n  const { refresh_token } = JSON.parse(access);\n  if (!refresh_token) {\n    devLog(`No refresh token. Needs re-authentication`);\n    localStorage.clear();\n    window.location.reload();\n    return;\n  }\n  const fetchUpdate = await fetch(\n    `${corsPrefix}https://www.reddit.com/api/v1/access_token`,\n    {\n      method: \"POST\",\n      headers: {\n        Authorization: `Basic ${btoa(CLIENT_ID + \":\")}`,\n        \"Content-Type\": \"application/x-www-form-urlencoded;charset=UTF-8\",\n      },\n      body: stringify({\n        grant_type: \"refresh_token\",\n        refresh_token,\n      }),\n    }\n  );\n  const parsedResponse = await fetchUpdate.json();\n  const expiryDate = new Date();\n  expiryDate.setSeconds(expiryDate.getSeconds() + parsedResponse.expires_in);\n  window.localStorage.setItem(\n    \"access\",\n    JSON.stringify({\n      ...parsedResponse,\n      refresh_token,\n      expiryDate,\n    })\n  );\n};\n\nconst Auth = () => {\n  let location = useLocation();\n  const history = useHistory();\n  const { code } = parse(location.search);\n  const getBearer = async () => {\n    devLog(`Fetching bearer with code ${code}`);\n    const fetchBearer = await fetch(\n      `${corsPrefix}https://www.reddit.com/api/v1/access_token`,\n      {\n        method: \"post\",\n        headers: {\n          Authorization: `Basic ${btoa(CLIENT_ID + \":\")}`,\n          \"Content-Type\": \"application/x-www-form-urlencoded;charset=UTF-8\",\n        },\n        body: stringify({\n          grant_type: \"authorization_code\",\n          code,\n          redirect_uri: REDIRECT_URL,\n        }),\n      }\n    );\n    const parsedResponse = await fetchBearer.json();\n    devLog(`Get bearer response ${parsedResponse}`);\n    if (parsedResponse.error) {\n      devLog(`Couldn't get initial bearer token ${parsedResponse}`);\n      return;\n    }\n    const expiryDate = new Date();\n    expiryDate.setSeconds(expiryDate.getSeconds() + parsedResponse.expires_in);\n    window.localStorage.setItem(\n      \"access\",\n      JSON.stringify({\n        ...parsedResponse,\n        expiryDate,\n      })\n    );\n    history.push(\"/\");\n  };\n  getBearer().then(devLog);\n  return <div className=\"home\">Checking authentication</div>;\n};\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Router basename={process.env.PUBLIC_URL}>\n        <Switch>\n          <Route exact path=\"/auth\" component={Auth} />\n          <Route exact path=\"/\" component={Home} />\n          <Redirect to=\"/\" />\n        </Switch>\n      </Router>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}